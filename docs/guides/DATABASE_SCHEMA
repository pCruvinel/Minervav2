### A Estrutura "Padrão Ouro" para Contexto de IA

Para que a IA nunca erre nem o código e nem a regra, eu recomendo atualizar o seu `DATABASE_SCHEMA.md` para ter **duas seções**:

1.  **Definições Lógicas (O Markdown que fizemos):** Para ela entender "quem faz o quê".
2.  **Schema Compacto (Pseudo-SQL):** Para ela saber os nomes exatos das colunas.

Vou refazer o documento abaixo neste formato **otimizado para LLMs**. Ele remove a verbosidade do SQL (como `CONSTRAINT`, `DEFAULT btree`, etc.) e foca no que importa: nomes, tipos, relacionamentos e regras.

**Substitua o conteúdo do seu arquivo por este aqui. É a melhor versão possível para uma IA consumir:**

````markdown
# AI Context: Minerva Database Schema

**Context:** Database for a construction/engineering company (Minerva).
**Tech:** Supabase (PostgreSQL).
**Key Architecture:** Users are in `auth.users` but extended profile is in `public.colaboradores`. Permissions are handled via `cargos` (RBAC) and `setores` tables.

---

## 1. Business Logic & Permissions (Crucial)

### Access Levels (Hierarquia)
The system uses a tiered access model enforced by RLS:
1.  **Level 1 (Admin/Diretoria):** Full access (SELECT, INSERT, UPDATE, DELETE) to ALL tables.
2.  **Level 2 (Gestores - Cross-Section):**
    * `gestor_obras`: Manages everything related to sector 'obras'.
    * `gestor_assessoria`: Manages everything related to sector 'assessoria'.
    * `gestor_administrativo`: Super-manager. Sees 'administrativo' AND 'obras' AND 'assessoria'.
3.  **Level 3 (Colaborador):**
    * Can only see their own profile.
    * Can only see OS (Service Orders) where they are the `responsavel_id`.
    * Can see items explicitly delegated to them via `delegacoes`.

### Important Flows
* **User Creation:** Trigger `on_auth_user_created` calls `handle_new_user()`. Sets default cargo to 'colaborador'.
* **OS Visibility:** Inherited. If a user can see the parent `ordens_servico`, they can see its children (`os_etapas`, `os_anexos`).

---

## 2. Schema Definition (Table Structure)

### 2.1 Organization & Users

```sql
TABLE public.cargos (
  id uuid PK,
  nome text, -- "Gestor de Obras"
  slug text UNIQUE, -- 'admin', 'diretoria', 'gestor_obras', 'gestor_assessoria', 'gestor_administrativo', 'colaborador'
  nivel_acesso int -- 10=Admin, 9=Diretoria, 5=Gestor, 1=Operacional
);

TABLE public.setores (
  id uuid PK,
  nome text, -- "Obras", "Assessoria"
  slug text UNIQUE -- 'obras', 'assessoria', 'administrativo', 'diretoria'
);

TABLE public.colaboradores (
  id uuid PK FK(auth.users), -- 1:1 relation with Auth
  nome_completo text,
  email text,
  cargo_id uuid FK(cargos.id),
  setor_id uuid FK(setores.id),
  ativo boolean DEFAULT true
);
````

### 2.2 Core Business (Service Orders)

```sql
TABLE public.ordens_servico (
  id uuid PK,
  codigo_os varchar UNIQUE, -- 'OS-2024-001'
  cliente_id uuid FK(clientes.id),
  tipo_os_id uuid FK(tipos_os.id),
  responsavel_id uuid FK(colaboradores.id), -- The technician executing the job
  criado_por_id uuid FK(colaboradores.id),
  status_geral enum, -- 'EM_TRIAGEM', 'EM_ANDAMENTO', 'CONCLUIDO', 'CANCELADO'
  valor_contrato numeric,
  descricao text
);

TABLE public.os_etapas (
  id uuid PK,
  os_id uuid FK(ordens_servico.id),
  nome_etapa text,
  status enum, -- 'PENDENTE', 'EM_ANDAMENTO', 'CONCLUIDA', 'BLOQUEADA'
  dados_etapa jsonb -- Stores dynamic form data for this step
);

TABLE public.os_anexos (
  id uuid PK,
  os_id uuid FK(ordens_servico.id),
  path_storage text,
  nome_arquivo text
);

TABLE public.delegacoes (
  id uuid PK,
  os_id uuid FK(ordens_servico.id),
  delegado_id uuid FK(colaboradores.id), -- Who received the task
  delegante_id uuid FK(colaboradores.id), -- Who gave the task
  status_delegacao enum -- 'PENDENTE', 'ACEITA', 'RECUSADA', 'CONCLUIDA'
);
```

### 2.3 Financial & CRM

```sql
TABLE public.clientes (
  id uuid PK,
  nome_razao_social text,
  cpf_cnpj varchar,
  status enum, -- 'LEAD', 'ATIVO', 'INATIVO'
  responsavel_id uuid FK(colaboradores.id)
);

TABLE public.financeiro_lancamentos (
  id uuid PK,
  descricao text,
  valor numeric,
  tipo enum, -- 'RECEITA', 'DESPESA'
  data_vencimento date,
  cc_id uuid FK(centros_custo.id)
);

TABLE public.centros_custo (
  id uuid PK,
  nome text,
  valor_global numeric
);
```

### 2.4 Calendar

```sql
TABLE public.turnos (
  id uuid PK,
  hora_inicio time,
  hora_fim time,
  vagas_total int,
  setores text[] -- Array of sector slugs allowed
);

TABLE public.agendamentos (
  id uuid PK,
  turno_id uuid FK(turnos.id),
  data date,
  os_id uuid FK(ordens_servico.id),
  solicitante_nome text, -- If purely lead
  status varchar -- 'confirmado', 'cancelado'
);
```

-----

## 3\. Quick Reference: Enums

  * **`os_status_geral`**: `EM_TRIAGEM`, `EM_ANDAMENTO`, `CONCLUIDO`, `CANCELADO`
  * **`os_etapa_status`**: `PENDENTE`, `EM_ANDAMENTO`, `CONCLUIDA`, `BLOQUEADA`
  * **`cliente_status`**: `LEAD`, `ATIVO`, `INATIVO`
  * **`financeiro_tipo`**: `RECEITA`, `DESPESA`

-----

## 4\. Common Queries Patterns

**Check Permission:**
Always join `colaboradores` -\> `cargos` to check `slug` or `nivel_acesso`.

```sql
-- Example: Is user a manager?
SELECT 1 FROM colaboradores c 
JOIN cargos cg ON c.cargo_id = cg.id 
WHERE c.id = auth.uid() AND cg.nivel_acesso >= 5;
```

**Get OS with Details:**

```sql
SELECT os.*, c.nome_razao_social, t.nome as tipo_os
FROM ordens_servico os
JOIN clientes c ON os.cliente_id = c.id
JOIN tipos_os t ON os.tipo_os_id = t.id;
```

```

### Por que este formato é melhor para IA?
1.  **Compacto:** Remove o ruído do SQL (`NOT NULL DEFAULT gen_random_uuid() ...`) que a IA "adivinha", mas mantém os nomes exatos das tabelas e colunas.
2.  **Relationships Explícitos:** Note que eu coloquei `FK(tabela.id)` ao lado das colunas. Isso ajuda a IA a saber como fazer `JOIN` sem precisar ler constraints no final do arquivo.
3.  **Business Logic Primeiro:** A IA lê de cima para baixo. Ao explicar a regra de acesso *antes* das tabelas, ela entende o contexto de qualquer query que você pedir depois.
```